{"version":3,"file":"form-builder.js","sourceRoot":"","sources":["../../../src/components/form-builder/form-builder.tsx"],"names":[],"mappings":"AAAA,OAAO,EACL,SAAS,EAET,OAAO,EACP,KAAK,EAEL,CAAC,EACD,IAAI,EAEJ,MAAM,EACN,IAAI,EACJ,KAAK,EACL,KAAK,EACN,MAAM,eAAe,CAAA;AAEtB,OAAO,KAAK,GAAG,MAAM,KAAK,CAAA;AAQ1B,MAAM,OAAO,WAAW;;;;uBAGK,KAAK;;uBAEY,KAAK;;;;8BAKd,KAAK;iCACF,KAAK;;IAgB3C;;;;OAIG;IACH,KAAK,CAAC,QAAQ,CAAE,CAAQ;QACtB,CAAC,CAAC,cAAc,EAAE,CAAC;QACnB,CAAC,CAAC,eAAe,EAAE,CAAA;QAEnB,MAAM,aAAa,GAAG,IAAI,CAAC,EAAE,CAAC,gBAAgB,CAA6D,yBAAyB,CAAC,CAAC;QAEtI,IAAI,CAAC,qBAAqB,EAAE,CAAC;QAC7B,IAAI,CAAC,cAAc,GAAG,KAAK,CAAA;QAE3B,IAAI;YACF,kCAAkC;YAClC,MAAM,YAAY,GAAG,EAAE,CAAC;YAExB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;;gBACvC,IAAI,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;gBAE/B,MAAM,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,KAAK,GAAG,CAAC,CAAC;gBAEvE,IAAI,KAAK,CAAC,IAAI,KAAK,UAAU,EAAE;oBAC7B,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,MAAA,KAAK,CAAC,KAAK,mCAAI,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;iBAC5C;gBAED,YAAY,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;YAC5B,CAAC,CAAC,CAAC;YAEH,aAAa,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;YAEzE,gBAAgB;YAChB,MAAM,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,YAAY,EAAE;gBAC9C,UAAU,EAAE,KAAK;aAClB,CAAC,CAAC;YAEH,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;YAEpB,iCAAiC;YACjC,MAAM,IAAI,CAAC,aAAa,CAAC,gBAAgB,EAAE,YAAY,CAAC,CAAC;YAEzD,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE;gBAC5B,IAAI,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC;aACnC;iBAAM;gBACL,MAAM,IAAI,CAAC,aAAa,CAAC,UAAU,EAAE,YAAY,CAAC,CAAC;aACpD;YAED,+BAA+B;YAC/B,MAAM,IAAI,CAAC,aAAa,CAAC,eAAe,EAAE,YAAY,CAAC,CAAC;YAExD,IAAI,CAAC,cAAc,GAAG,IAAI,CAAA;SAC3B;QAAC,OAAO,CAAC,EAAE;YACV,IAAI,CAAC,CAAC,IAAI,KAAK,iBAAiB,EAAE;gBAChC,MAAM,IAAI,CAAC,qBAAqB,CAAC,CAAC,CAAC,CAAC;aACrC;YAED,MAAM,IAAI,CAAC,aAAa,CAAC,eAAe,EAAE,CAAC,CAAC,CAAC;SAC9C;QAED,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;IACvB,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,OAAO,CAAE,CAAQ;QACrB,CAAC,CAAC,cAAc,EAAE,CAAC;QACnB,CAAC,CAAC,eAAe,EAAE,CAAA;QAEnB,MAAM,IAAI,CAAC,aAAa,CAAC,eAAe,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;QAEzD,IAAI,CAAC,QAAQ,qBAAQ,IAAI,CAAC,aAAa,CAAE,CAAC;QAC1C,IAAI,CAAC,qBAAqB,EAAE,CAAC;QAE7B,MAAM,IAAI,CAAC,aAAa,CAAC,cAAc,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;IAC1D,CAAC;IAED;;;;;;OAMG;IAEH,cAAc,CAAE,QAAgC;QAC9C,IAAI,CAAC,QAAQ,EAAE;YACb,MAAM,IAAI,KAAK,CAAC,uCAAuC,CAAC,CAAC;SAC1D;QAED,IAAI,MAAqB,CAAC;QAE1B,6CAA6C;QAC7C,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;YAChC,oCAAoC;YACpC,IAAI;gBACF,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;aAC/B;YAAC,OAAO,CAAC,EAAE;gBACV,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;aACnD;SACF;aAAM;YACL,MAAM,GAAG,QAAQ,CAAC;SACnB;QAED,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;YACxB,sCAAsC;YACtC,sDAAsD;YACtD,KAAK,CAAC,EAAE,GAAG,CAAC,KAAK,CAAC,EAAE,IAAI,KAAK,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACzF,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC;IAC3B,CAAC;IAED;;;OAGG;IAEH,gBAAgB;QACd,IAAI,CAAC,oBAAoB,EAAE,CAAC;IAC9B,CAAC;IAED;;OAEG;IAEH,KAAK,CAAC,WAAW;QACf,OAAO,IAAI,CAAC,QAAQ,CAAC;IACvB,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,kBAAkB,CAAE,KAAyB,EAAE,KAAU;QAC7D,IAAI,CAAC,QAAQ,mCACR,IAAI,CAAC,QAAQ,KAChB,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,KAAK,GACpB,CAAC;QAEF,oDAAoD;QACpD,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE;YACzB,MAAM,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;SACvC;IACH,CAAC;IAED;;;;;OAKG;IACH,qBAAqB,CAAE,KAA0B;QAC/C,MAAM,aAAa,qBAAQ,IAAI,CAAC,UAAU,CAAE,CAAC;QAE7C,2DAA2D;QAC3D,IAAI,KAAK,EAAE;YACT,IAAI,CAAC,cAAc,CAAC,aAAa,EAAE,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;SAC3D;aAAM;YACL,2BAA2B;YAC3B,aAAa,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,MAAM,GAAG,SAAS,CAAC,CAAC,CAAC;SACnE;QAED,IAAI,CAAC,UAAU,GAAG,aAAa,CAAC;IAClC,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,qBAAqB,CAAE,CAAsB;QACjD,MAAM,SAAS,qBAAQ,IAAI,CAAC,UAAU,CAAE,CAAC;QACzC,MAAM,MAAM,GAAuC,EAAE,CAAC;QAEtD,oEAAoE;QACpE,IAAI,CAAC,CAAC,KAAK,CAAC,MAAM,EAAE;YAClB,6EAA6E;YAC7E,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,GAAwB,EAAE,EAAE;gBAC3C,MAAM,CAAC,IAAI,CAAC;oBACV,KAAK,EAAE,GAAG,CAAC,IAAI;oBACf,KAAK,EAAE,GAAG,CAAC,OAAO;iBACnB,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;SACJ;aAAM;YACL,MAAM,CAAC,IAAI,CAAC;gBACV,KAAK,EAAE,CAAC,CAAC,IAAI;gBACb,KAAK,EAAE,CAAC,CAAC,OAAO;aACjB,CAAC,CAAC;SACJ;QAED,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;YACnB,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;QACvD,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;QAE5B,MAAM,IAAI,CAAC,aAAa,CAAC,oBAAoB,EAAE,EAAE,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,MAAM,EAAE,CAAC,EAAE,CAAC,CAAA;IACxF,CAAC;IAED;;;;;;OAMG;IACH,cAAc,CAAE,MAAqB,EAAE,SAAiB,EAAE,KAAa;QACrE,MAAM,KAAK,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC;QAEpE,mDAAmD;QACnD,IAAI,KAAK,EAAE;YACT,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC;SACtB;IACH,CAAC;IAED;;;;;;OAMG;IACH,oBAAoB;QAClB,MAAM,SAAS,GAAG,EAAE,CAAC;QAErB,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;YACrC,MAAM,EAAE,SAAS,EAAE,QAAQ,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;YAEjE,+DAA+D;YAC/D,IAAI,QAAQ,IAAI,QAAQ,IAAI,CAAC,SAAS,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE;gBAC3D,OAAO;aACR;YAED,wCAAwC;YACxC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,UAAU,CAAC,GAAG,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;QACpE,CAAC,CAAC,CAAC;QAEH,wCAAwC;QAExC,8BAA8B;QAC9B,IAAI,CAAC,aAAa,GAAG,GAAG,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;IAC7C,CAAC;IAED;;;;;;;;OAQG;IACH,cAAc,CAAE,KAAyB,EAAE,YAAoB,EAAE,eAAwB,KAAK;QAC5F,IAAI,QAAQ,GAAG,YAAY,CAAC;QAE5B,4FAA4F;QAC5F,4DAA4D;QAC5D,IAAI,KAAK,CAAC,cAAc,CAAC,YAAY,CAAC,EAAE;YACtC,IAAI,OAAO,KAAK,CAAC,YAAY,CAAC,KAAK,UAAU,EAAE;gBAC7C,QAAQ,GAAG,KAAK,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;aAC/C;iBAAM;gBACL,QAAQ,GAAG,KAAK,CAAC,YAAY,CAAC,CAAC;aAChC;SACF;QAED,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED;;;;;OAKG;IACH,UAAU,CAAE,KAAyB;QAKnC,OAAO;YACL,SAAS,EAAE,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,YAAY,EAAE,IAAI,CAAC;YACzD,QAAQ,EAAE,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,UAAU,CAAC;YAChD,QAAQ,EAAE,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,UAAU,CAAC;SACjD,CAAC;IACJ,CAAC;IAED,KAAK,CAAC,mBAAmB,CAAE,KAAyB;QAClD,IAAI,CAAC,qBAAqB,CAAC,KAAK,CAAC,CAAC;QAElC,IAAI;YACF,MAAM,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;SAChE;QAAC,OAAO,CAAC,EAAE;YACV,IAAI,CAAC,CAAC,IAAI,KAAK,iBAAiB,EAAE;gBAChC,MAAM,IAAI,CAAC,qBAAqB,CAAC,CAAC,CAAC,CAAC;aACrC;SACF;IACH,CAAC;IAED;;;;;OAKG;IACH,cAAc,CAAE,YAAiB;QAC/B,MAAM,IAAI,GAAG,QAAQ,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;QAC5C,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QAC1B,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QAE1B,0DAA0D;QAC1D,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;YACtC,MAAM,KAAK,GAAG,QAAQ,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;YAC9C,KAAK,CAAC,IAAI,GAAG,QAAQ,CAAC;YACtB,KAAK,CAAC,IAAI,GAAG,GAAG,CAAC;YACjB,KAAK,CAAC,KAAK,GAAG,YAAY,CAAC,GAAG,CAAC,CAAC;YAChC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QAC1B,CAAC,CAAC,CAAC;QAEH,4CAA4C;QAC5C,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QAChC,IAAI,CAAC,MAAM,EAAE,CAAC;IAChB,CAAC;IACD,KAAK,CAAC,aAAa,CAAE,IAAY,EAAE,GAAG,IAAS;QAC7C,IAAI,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,CAAA;QAE3C;;;;WAIG;QACH,MAAM,MAAM,GAAG,CAAC,IAAI,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAA;QACxD,IAAI,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,CAAA;QAEjC,wDAAwD;QACxD,iBAAiB;QACjB,IAAI,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE;YACxC,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;SACvC;QAED,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;IAC3B,CAAC;IAGD,uBAAuB;QACrB,IAAI,CAAC,iBAAiB,GAAG,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,MAAM,CAAA;IACjE,CAAC;IAED;;;;;OAKG;IACH,iBAAiB,CAAE,KAAyB;QAC1C,MAAM,EAAE,SAAS,EAAE,QAAQ,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;QAEjE,OAAO,CAAC,GAAG,CAAC,mBAAmB,EAAE,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAA;QAEvE,+DAA+D;QAC/D,IAAI,CAAC,SAAS,EAAE;YACd,gFAAgF;YAChF,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;YAE/B,OAAO,IAAI,CAAC;SACb;QAED,MAAM,KAAK,GAAG;YACZ,GAAG,EAAE,KAAK,CAAC,EAAE;YACb,QAAQ,EAAE,QAAQ;YAClB,QAAQ,EAAE,QAAQ;YAClB,IAAI,EAAE,KAAK,CAAC,IAAc;YAC1B,+CAA+C;YAC/C,YAAY,EAAE,CAAC,CAAc,EAAE,EAAE,CAAC,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,CAAC,CAAC,MAAM,CAAC;SAC3E,CAAC;QAEF,kGAAkG;QAClG,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE;YACxB,KAAK,CAAC,eAAe,CAAC,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;SAChE;QAED,0CAA0C;QAE1C,QAAQ,KAAK,CAAC,IAAI,EAAE;YAClB,KAAK,MAAM,CAAC;YACZ,KAAK,OAAO,CAAC;YACb,KAAK,UAAU;gBACb,OAAO,CACL,sCAAoB,KAAK,EACL,KAAK,IACT,KAAK,EAAE,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,EAChC,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,KAAK,OAAO,IAAI,IAAI,CAAC,MAAM,CAAC,aAAa,EAAE,IAC5E,CACH,CAAC;YAEJ,KAAK,UAAU;gBACb,OAAO,CACL,0CAAwB,KAAK,EACL,KAAK,IACT,OAAO,EAAE,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,IAChC,CACvB,CAAA;YAEH,KAAK,QAAQ;gBACX,OAAO,CACL,wCAAsB,KAAK,EACL,KAAK,IACT,KAAK,EAAE,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,IAChD,CACH,CAAA;YAEH;gBACE,OAAO,oCAA6B,CAAC;SACxC;IACH,CAAC;IAED;;;OAGG;IACH,iBAAiB;;QACf,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAEjC,4BAA4B;QAE5B,oCAAoC;QACpC,IAAI,CAAC,aAAa,GAAG,MAAA,IAAI,CAAC,UAAU,0CAAE,MAAM,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,KAAK,EAAE,EAAE;;YACjE,IAAI,KAAK,GAAG,MAAA,KAAK,CAAC,KAAK,mCAAI,EAAE,CAAC;YAE9B,IAAI,KAAK,CAAC,IAAI,KAAK,UAAU,EAAE;gBAC7B,KAAK,GAAG,MAAA,KAAK,CAAC,OAAO,mCAAI,KAAK,CAAC;aAChC;YAED,uCAAY,GAAG,KAAE,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,KAAK,IAAG;QACzC,CAAC,EAAE,EAAE,CAAC,CAAC;QACP,IAAI,CAAC,QAAQ,qBAAQ,IAAI,CAAC,aAAa,CAAE,CAAC;IAC5C,CAAC;IAED;;;OAGG;IACH,MAAM;;QACJ,OAAO,CACL,EAAC,IAAI,IAAC,KAAK,EAAE,EAAE,SAAS,EAAE,IAAI,CAAC,OAAO,EAAE;YAEtC,YAAM,MAAM,EAAE,IAAI,CAAC,MAAM,EACnB,MAAM,EAAE,IAAI,CAAC,MAAM,EACnB,GAAG,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC,EAC7B,KAAK,EAAE,EAAE,OAAO,EAAE,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,MAAM,CAAA,CAAC,CAAC,EAAE,EAAC,EACtD,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,EAC/B,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;gBAGjC,eAAa,EAEZ,MAAA,IAAI,CAAC,UAAU;mBAAE,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;gBAEpE,YAAM,IAAI,EAAC,SAAS;oBAClB,cAAQ,IAAI,EAAC,OAAO,EAAC,IAAI,EAAC,UAAU,EAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,YAElD;oBACT,cAAQ,IAAI,EAAC,QAAQ,EAAC,IAAI,EAAC,WAAW,EAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,aAEpD,CACJ,CACF;YAEP,WAAK,GAAG,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,eAAe,GAAG,CAAC,EAAE,KAAK,EAAE,EAAE,OAAO,EAAE,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,OAAO,CAAA,CAAC,CAAC,MAAM,EAAC;gBACpG,YAAM,IAAI,EAAC,aAAa,GAChB,CACJ,CACD,CACR,CAAC;IACJ,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CACF","sourcesContent":["import {\n  Component,\n  ComponentInterface,\n  Element,\n  Event,\n  EventEmitter,\n  h,\n  Host,\n  JSX,\n  Method,\n  Prop,\n  State,\n  Watch\n} from '@stencil/core'\nimport { WabFormSchema, WabFormSchemaField } from './wab-form-schema'\nimport * as yup from 'yup'\nimport { ValidationError } from 'yup'\n\n@Component({\n  tag: 'wab-form-builder',\n  styleUrl: 'form-builder.css',\n  shadow: false,\n})\nexport class FormBuilder implements ComponentInterface {\n  @Prop() action: string;\n  @Prop() method: string;\n  @Prop() useAjax: Boolean = false;\n  @Prop() schema: string | WabFormSchema;\n  @Prop({ mutable: true }) loading: boolean = false;\n  \n  @State() formData: any;\n  @State() formSchema: WabFormSchema;\n  @State() formValidator: yup.Schema;\n  @State() submitComplete: boolean = false\n  @State() showAfterSubmitEl: boolean = false\n  \n  @Element() el: HTMLElement;\n  \n  @Event() wabBeforeSubmit: EventEmitter<any>\n  @Event() wabSubmit: EventEmitter<any>\n  @Event() wabAfterSubmit: EventEmitter<any>\n  @Event() wabSubmitError: EventEmitter<any>\n  @Event() wabBeforeReset: EventEmitter<any>\n  @Event() wabAfterReset: EventEmitter<any>\n  @Event() wabValidationErrors: EventEmitter<{ formData: Record<string, any>, errors: ValidationError }>\n  \n  afterSubmitSlot: Element\n  formEl: HTMLFormElement;\n  initialValues: any;\n  \n  /**\n   * Event handler for the form submission\n   *\n   * @param {Event} e\n   */\n  async onSubmit (e: Event) {\n    e.preventDefault();\n    e.stopPropagation()\n    \n    const slottedInputs = this.el.querySelectorAll<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>('input, select, textarea');\n    \n    this.resetValidationErrors();\n    this.submitComplete = false\n    \n    try {\n      // Retrieve all data from the form\n      const dataToSubmit = {};\n      \n      Object.keys(this.formData).forEach(key => {\n        let value = this.formData[key];\n        \n        const field = this.formSchema.fields.find(field => field.name === key);\n        \n        if (field.type === 'checkbox') {\n          value = value ? (field.value ?? true) : '';\n        }\n        \n        dataToSubmit[key] = value;\n      });\n      \n      slottedInputs.forEach(input => (dataToSubmit[input.name] = input.value));\n      \n      // Validate form\n      await this.formValidator.validate(dataToSubmit, {\n        abortEarly: false,\n      });\n      \n      this.loading = true;\n      \n      // console.log('onbeforesubmit');\n      await this.invokeEventFn('onBeforeSubmit', dataToSubmit);\n      \n      if (!this.formSchema.useAjax) {\n        this.submitFakeForm(dataToSubmit);\n      } else {\n        await this.invokeEventFn('onSubmit', dataToSubmit);\n      }\n      \n      // console.log('after submit');\n      await this.invokeEventFn('onAfterSubmit', dataToSubmit);\n      \n      this.submitComplete = true\n    } catch (e) {\n      if (e.name === 'ValidationError') {\n        await this.storeValidationErrors(e);\n      }\n      \n      await this.invokeEventFn('onSubmitError', e);\n    }\n    \n    this.loading = false;\n  }\n  \n  /**\n   * Event handler for the form reset\n   *\n   * @param {Event} e\n   */\n  async onReset (e: Event) {\n    e.preventDefault();\n    e.stopPropagation()\n    \n    await this.invokeEventFn('onBeforeReset', this.formData);\n    \n    this.formData = { ...this.initialValues };\n    this.resetValidationErrors();\n    \n    await this.invokeEventFn('onAfterReset', this.formData);\n  }\n  \n  /**\n   * Watcher for the schema prop change.\n   * When this changes, we need to parse the schema and add an id to each field and store it\n   * in the this.formSchema state\n   *\n   * @param {string | WabFormSchema} newValue\n   */\n  @Watch('schema')\n  onSchemaChange (newValue: string | WabFormSchema) {\n    if (!newValue) {\n      throw new Error('You must provide a schema to the form');\n    }\n    \n    let schema: WabFormSchema;\n    \n    // If the schema is a string (JSON), parse it\n    if (typeof newValue === 'string') {\n      // ensure the schema is a valid JSON\n      try {\n        schema = JSON.parse(newValue);\n      } catch (e) {\n        throw new Error('The schema is not a valid JSON');\n      }\n    } else {\n      schema = newValue;\n    }\n    \n    schema.fields.map(field => {\n      // If the field has no id, create one.\n      // This id will be used to link the label to the input\n      field.id = (field.id || field.name) + '_' + Math.random().toString(36).substring(2, 9);\n    });\n    \n    this.formSchema = schema;\n  }\n  \n  /**\n   * Watcher for the formData prop change.\n   * When this changes, we need to rebuild the validator schema\n   */\n  @Watch('formData')\n  onFormDataChange () {\n    this.buildValidatorSchema();\n  }\n  \n  /**\n   * Return the actual form data\n   */\n  @Method()\n  async getFormData () {\n    return this.formData;\n  }\n  \n  /**\n   * Event handler for the input value change. This will be on keyup for text inputs\n   *\n   * @param {WabFormSchemaField} field\n   * @param {any} value\n   */\n  async onInputValueChange (field: WabFormSchemaField, value: any) {\n    this.formData = {\n      ...this.formData,\n      [field.name]: value\n    };\n    \n    // If the field is not lazy, validate it immediately\n    if (!this.formSchema.lazy) {\n      await this.validateSingleField(field);\n    }\n  }\n  \n  /**\n   * Reset the validation errors by resetting the form validator\n   * and setting to undefined each field's \"errors\" property\n   *\n   * @param {WabFormSchemaField} field\n   */\n  resetValidationErrors (field?: WabFormSchemaField) {\n    const newFormSchema = { ...this.formSchema };\n    \n    // If a field is provided, reset only its \"errors\" property\n    if (field) {\n      this.setFieldErrors(newFormSchema, field.name, undefined);\n    } else {\n      // reset the form validator\n      newFormSchema.fields.forEach(field => (field.errors = undefined));\n    }\n    \n    this.formSchema = newFormSchema;\n  }\n  \n  /**\n   * Store the validation errors in the form schema\n   * by setting the \"errors\" property of each field\n   *\n   * @param {yup.ValidationError} e\n   */\n  async storeValidationErrors (e: yup.ValidationError) {\n    const newSchema = { ...this.formSchema };\n    const errors: { field: string, error: string }[] = [];\n    \n    // If the error has inner errors, it means there are multiple errors\n    if (e.inner.length) {\n      // for each error, find the corresponding field and set its \"errors\" property\n      e.inner.forEach((err: yup.ValidationError) => {\n        errors.push({\n          field: err.path,\n          error: err.message,\n        });\n      });\n    } else {\n      errors.push({\n        field: e.path,\n        error: e.message,\n      });\n    }\n    \n    errors.forEach(err => {\n      this.setFieldErrors(newSchema, err.field, err.error);\n    });\n    \n    this.formSchema = newSchema;\n    \n    await this.invokeEventFn('onValidationErrors', { formData: this.formData, errors: e })\n  }\n  \n  /**\n   * Set the \"errors\" property of a field\n   *\n   * @param schema\n   * @param fieldName\n   * @param error\n   */\n  setFieldErrors (schema: WabFormSchema, fieldName: string, error: string) {\n    const field = schema.fields.find(field => field.name === fieldName);\n    \n    // If the field is found, set its \"errors\" property\n    if (field) {\n      field.errors = error;\n    }\n  }\n  \n  /**\n   * Build the validator schema based on the form schema\n   *\n   * While building the schema, we check if the field is disabled or readonly or is visible\n   * If so, none of its validators will be added to the schema and evaluated\n   *\n   */\n  buildValidatorSchema () {\n    const rawSchema = {};\n    \n    this.formSchema.fields.forEach(field => {\n      const { condition, disabled, readonly } = this.checkField(field);\n      \n      // If the field is disabled or readonly or not visible, skip it\n      if (disabled || readonly || !condition || !field.validators) {\n        return;\n      }\n      \n      // Add the field to the validator schema\n      rawSchema[field.name] = field.validators(yup, this.formValidator);\n    });\n    \n    // console.log('validators', rawSchema);\n    \n    // Create the validator schema\n    this.formValidator = yup.object(rawSchema);\n  }\n  \n  /**\n   * Check the computed value of a property of a field.\n   * If the property is a function, call it with the formData as argument.\n   *\n   * @param {WabFormSchemaField} field\n   * @param {string} conditionKey\n   * @param {boolean} defaultValue - The default value to return if the key is not found on the field\n   * @returns {boolean}\n   */\n  checkCondition (field: WabFormSchemaField, conditionKey: string, defaultValue: boolean = false): boolean {\n    let toReturn = defaultValue;\n    \n    // If the key exists on the field, check if the value is a function and eventually invoke it\n    // with the formData as argument, otherwise return the value\n    if (field.hasOwnProperty(conditionKey)) {\n      if (typeof field[conditionKey] === 'function') {\n        toReturn = field[conditionKey](this.formData);\n      } else {\n        toReturn = field[conditionKey];\n      }\n    }\n    \n    return toReturn;\n  }\n  \n  /**\n   * Check if the field is visible, disabled or readonly\n   *\n   * @param {WabFormSchemaField} field\n   * @returns {{condition: boolean, disabled: boolean, readonly: boolean}}\n   */\n  checkField (field: WabFormSchemaField): {\n    condition: boolean;\n    disabled: boolean;\n    readonly: boolean;\n  } {\n    return {\n      condition: this.checkCondition(field, 'conditions', true),\n      disabled: this.checkCondition(field, 'disabled'),\n      readonly: this.checkCondition(field, 'readonly'),\n    };\n  }\n  \n  async validateSingleField (field: WabFormSchemaField) {\n    this.resetValidationErrors(field);\n    \n    try {\n      await this.formValidator.validateAt(field.name, this.formData);\n    } catch (e) {\n      if (e.name === 'ValidationError') {\n        await this.storeValidationErrors(e);\n      }\n    }\n  }\n  \n  /**\n   * Create a fake form and submit it\n   * Use only if \"useAjax\" is false\n   *\n   * @param {any} dataToSubmit\n   */\n  submitFakeForm (dataToSubmit: any) {\n    const form = document.createElement('form');\n    form.action = this.action;\n    form.method = this.method;\n    \n    // Add all the data to submit as hidden inputs to the form\n    Object.keys(dataToSubmit).forEach(key => {\n      const input = document.createElement('input');\n      input.type = 'hidden';\n      input.name = key;\n      input.value = dataToSubmit[key];\n      form.appendChild(input);\n    });\n    \n    // Append the form to the body and submit it\n    document.body.appendChild(form);\n    form.submit();\n  }\n  async invokeEventFn (name: string, ...args: any): Promise<void> {\n    let eventToEmit = name.replace('on', 'wab')\n    \n    /**\n     * If args contains more than one element, wrap them in an array\n     * This is needed because the emit method accepts only one argument,\n     * and we want to pass all the arguments to the event handler\n     */\n    const toEmit = (args && args.length > 1 ? [args] : args)\n    this[eventToEmit].emit(...toEmit)\n    \n    // check if the schema has a function with the same name\n    // if so, call it\n    if (this.formSchema.hasOwnProperty(name)) {\n      return this.formSchema[name](...args);\n    }\n    \n    return Promise.resolve();\n  }\n  \n  @Watch('submitComplete')\n  onAfterSubmitSlotChange () {\n    this.showAfterSubmitEl = !!this.afterSubmitSlot.children.length\n  }\n  \n  /**\n   * Get the right component for the field based on its type\n   *\n   * @param {WabFormSchemaField} field\n   * @returns {JSX.Element}\n   */\n  getRightComponent (field: WabFormSchemaField): JSX.Element {\n    const { condition, disabled, readonly } = this.checkField(field);\n    \n    console.log('getRightComponent', field.name, this.formData[field.name])\n    \n    // If the field is not visible, return null and reset its value\n    if (!condition) {\n      // Reset the value of the field. This will also trigger the onValueChanged event\n      this.formData[field.name] = '';\n      \n      return null;\n    }\n    \n    const props = {\n      key: field.id,\n      disabled: disabled,\n      readonly: readonly,\n      part: field.type as string,\n      // exportparts:\"label, input, details, errors\",\n      onValueInput: (e: CustomEvent) => this.onInputValueChange(field, e.detail),\n    };\n    \n    // If the form is lazy, add the onValueChange event handler to trigger the validation of the field\n    if (this.formSchema.lazy) {\n      props['onValueChange'] = () => this.validateSingleField(field);\n    }\n    \n    // console.log('getRightComponent', field)\n    \n    switch (field.type) {\n      case 'text':\n      case 'email':\n      case 'password':\n        return (\n          <wab-text-input {...field}\n                          {...props}\n                          value={this.formData[field.name]}\n                          onKeyUp={e => e.key === 'Enter' && this.formEl.requestSubmit()}\n          />\n        );\n      \n      case 'checkbox':\n        return (\n          <wab-checkbox-input {...field}\n                              {...props}\n                              checked={this.formData[field.name]}\n          ></wab-checkbox-input>\n        )\n      \n      case 'select':\n        return (\n          <wab-select-input {...field}\n                            {...props}\n                            value={this.formData[field.name]}\n          />\n        )\n      \n      default:\n        return <div>Unknown field type</div>;\n    }\n  }\n  \n  /**\n   * Lifecycle hook\n   * When the component is loaded, parse the schema and assign initial values to formData\n   */\n  componentWillLoad () {\n    this.onSchemaChange(this.schema);\n    \n    // console.log(this.schema);\n    \n    // Assign initial values to formData\n    this.initialValues = this.formSchema?.fields.reduce((acc, field) => {\n      let value = field.value ?? '';\n      \n      if (field.type === 'checkbox') {\n        value = field.checked ?? false;\n      }\n      \n      return { ...acc, [field.name]: value };\n    }, {});\n    this.formData = { ...this.initialValues };\n  }\n  \n  /**\n   * Lifecycle hook\n   * Render the component\n   */\n  render () {\n    return (\n      <Host class={{ 'loading': this.loading }}>\n        \n        <form action={this.action}\n              method={this.method}\n              ref={el => (this.formEl = el)}\n              style={{ display: this.showAfterSubmitEl ? 'none': ''}}\n              onSubmit={e => this.onSubmit(e)}\n              onReset={e => this.onReset(e)}>\n          \n          {/* Custom inputs. Usually hidden ones */}\n          <slot></slot>\n          \n          {this.formSchema?.fields.map(field => this.getRightComponent(field))}\n          \n          <slot name='actions'>\n            <button type='reset' part='resetBtn' disabled={this.loading}>\n              Reset\n            </button>\n            <button type='submit' part='submitBtn' disabled={this.loading}>\n              Submit\n            </button>\n          </slot>\n        </form>\n        \n        <div ref={(e) => this.afterSubmitSlot = e} style={{ display: this.showAfterSubmitEl ? 'block': 'none'}}>\n          <slot name=\"afterSubmit\"\n          ></slot>\n        </div>\n      </Host>\n    );\n  }\n}\n"]}